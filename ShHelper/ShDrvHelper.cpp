#include <ShDrvInc.h>

/**
 * @file ShDrvHelper.cpp
 * @author Shh0ya (hunho88@gmail.com)
 * @brief Driver entry
 * @date 2022-12-30
 * @copyright the GNU General Public License v3
 */

PSH_GLOBAL_ROUTINES  g_Routines;  /**< Global routines */
PSH_GLOBAL_VARIABLES g_Variables; /**< Global variables */
PSH_GLOBAL_OFFSETS   g_Offsets;   /**< Global offsets data */
PSH_POOL_INFORMATION g_Pools;     /**< Global pool manager */

// LLVM is not support
//#pragma alloc_text("INIT", DriverEntry)

/**
* @brief Driver Entry
* @details Initialize global variable and major functions
* @param[in] PDRIVER_OBJECT `DriverObject`
* @param[in] PUNICODE_STRING `RegistryPath`
* @return If succeeds, return `STATUS_SUCCESS`, if fails return `STATUS_UNSUCCESSFUL`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT DriverObject, 
	IN PUNICODE_STRING RegistryPath)
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FUNCDNAME__, __FUNCTION__);
#endif
#endif
	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_SUCCESS;

	DriverObject->DriverUnload = HelperFinalize;

	Status = DriverInitialize();
	if (!NT_SUCCESS(Status)) { ShDrvPoolManager::Finalize(); ERROR_END }
	Log("Loaded driver");

	/*ShDrvExample::PeTest((HANDLE)848, (HANDLE)8764);
	ShDrvExample::ProcessTest((HANDLE)848);
	ShDrvExample::ProcessTest32((HANDLE)8764);
	ShDrvExample::MemoryScanTest();

	PHYSICAL_ADDRESS Physic = { 0, };
	ShDrvUtil::GetPhysicalAddressEx(g_Pools, KernelMode, &Physic);
	Log("%llX", Physic.QuadPart);*/
FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Driver Unload
* @details Clean to allocated pool and generated information
* @param[in] PDRIVER_OBJECT `DriverObject`
* @return VOID
* @author Shh0ya @date 2022-12-27
*/
VOID HelperFinalize(
	IN PDRIVER_OBJECT DriverObject)
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FUNCDNAME__, __FUNCTION__);
#endif
#endif
	SAVE_CURRENT_COUNTER;
	ShDrvPoolManager::Finalize();

	Log("Driver unload");

	PRINT_ELAPSED;
}

/**
* @brief [MACRO] Set module base address and end address
* @details if the value is not set, call ERROR_END
* @param[in] PCSTR `ModuleName`
* @param[in] `MemberName`
* @author Shh0ya @date 2022-12-27
* @see DriverInitialize
*/
#define INIT_BASEADDRESS(Module,Member)\
g_Variables->Member##BaseAddress = ShDrvCore::GetKernelBaseAddress(Module, &ImageSize, LoadedModuleList);\
g_Variables->Member##EndAddress = ADD_OFFSET(g_Variables->Member##BaseAddress, ImageSize, PVOID);\
if(g_Variables->Member##BaseAddress == nullptr || g_Variables->Member##BaseAddress == g_Variables->Member##EndAddress) { Status = STATUS_NOT_SUPPORTED; ERROR_END }

/**
* @brief Driver Initialize
* @details Initialize pool manager, global variables, global routines and global offsets
* @return If succeeds, return `STATUS_SUCCESS`, if fails return `STATUS_NOT_SUPPORTED`
* @author Shh0ya @date 2022-12-27
* @see GET_GLOBAL_POOL, INIT_BASEADDRESS, GET_EXPORT_VARIABLE, GET_EXPORT_ROUTINE
*/
NTSTATUS DriverInitialize()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FUNCDNAME__, __FUNCTION__);
#endif
#endif
	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_SUCCESS;
	ULONG64 ImageSize = 0;
	
	Status = ShDrvPoolManager::Initialize();
	if (!NT_SUCCESS(Status)) 
	{
		ShDrvPoolManager::Finalize();
		ERROR_END 
	}

	GET_GLOBAL_POOL(g_Routines, GLOBAL_ROUTINES);
	GET_GLOBAL_POOL(g_Variables, GLOBAL_VARIABLES);
	GET_GLOBAL_POOL(g_Offsets, GLOBAL_OFFSETS);

	g_Variables->KUserSharedData = reinterpret_cast<PKUSER_SHARED_DATA>(KUSER_SHARED_DATA_ADDRESS);
	g_Variables->BuildNumber = g_Variables->KUserSharedData->NtBuildNumber;
	
	g_Variables->SystemDirBase = __readcr3();

	INIT_BASEADDRESS("ntoskrnl.exe", System);
	INIT_BASEADDRESS("win32k.sys", Win32k);
	INIT_BASEADDRESS("win32kbase.sys", Win32kBase);
	INIT_BASEADDRESS("win32kfull.sys", Win32kFull);
	INIT_BASEADDRESS("cdd.dll", Cdd);
	INIT_BASEADDRESS("ci.dll", Ci);

	GET_EXPORT_VARIABLE(PsLoadedModuleList, PLIST_ENTRY);
	GET_EXPORT_VARIABLE(PsLoadedModuleResource, PERESOURCE);

	if (!NT_SUCCESS(Status)) { Status = STATUS_NOT_SUPPORTED; ERROR_END }

	Status = InitializeOffset_Unsafe();
	if (!NT_SUCCESS(Status)) { ERROR_END }

	GET_EXPORT_ROUTINE(PsGetProcessImageFileName, Ps);
	GET_EXPORT_ROUTINE(PsGetProcessPeb, Ps);
	GET_EXPORT_ROUTINE(PsGetProcessWow64Process, Ps);
	GET_EXPORT_ROUTINE(ObGetObjectType, Ob);

	if (!NT_SUCCESS(Status)) { Status = STATUS_NOT_SUPPORTED; ERROR_END }

FINISH:
	PRINT_ELAPSED;
	return Status;
}

/**
* @brief Initialize Offsets
* @warning This routine is unsafely. The symbol or other method(pattern scan, etc...) must be used
* Otherwise, must be checked if it's validate.
* @details Initialize offset value
* @return If succeeds, return `STATUS_SUCCESS`, if fails `NTSTATUS` value, not `STATUS_SUCCESS`
* @author Shh0ya @date 2022-12-27
*/
NTSTATUS InitializeOffset_Unsafe()
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FUNCDNAME__, __FUNCTION__);
#endif
#endif
	
	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_INVALID_PARAMETER;
	if(g_Offsets == nullptr || g_Variables == nullptr) { ERROR_END }

	switch (g_Variables->BuildNumber)
	{
	case WINDOWS_7:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0xDC);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0xE0);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x160);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x180);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x188);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x218);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x288);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x338);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x200);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x1f0);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x320);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x308);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x328);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x444);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x278);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x50);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xb8);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x164);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x210);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x388);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x3b0);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x410);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x420);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x438);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x448);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x44c);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x378);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0);
		break;
	}
	case WINDOWS_7_SP1:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0xDC);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0xE0);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x160);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x180);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x188);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x218);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x288);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x338);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x200);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x1f0);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x320);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x308);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x328);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x444);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x278);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x50);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xb8);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x164);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x210);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x388);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x3b0);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x410);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x420);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x438);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x448);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x44c);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x378);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0);
		break;
	}
	case WINDOWS_8:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x234);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x238);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2c8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x358);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3c8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3e8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x408);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x410);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x470);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x480);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x58c);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x590);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x630);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x370);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x398);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x3f0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x400);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x418);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x42c);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x430);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0);
		break;
	}
	case WINDOWS_8_1:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x234);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x238);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2c8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x358);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3c8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3e8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x408);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x410);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x470);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x480);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x5d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x5d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x660);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x5f8);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x620);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x678);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x688);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6a0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6b4);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6b8);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6d8);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x760);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x768);
		break;
	}
	case WINDOWS_10_1507:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x480);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x490);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x604);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x608);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x690);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x600);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x628);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x680);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6bc);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6e0);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x790);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x798);
		break;
	}
	case WINDOWS_10_1511:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x60c);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x610);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x698);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x600);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x628);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x680);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6bc);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6e0);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x790);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x798);
		break;
	}
	case WINDOWS_10_1607:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x61c);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x620);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6a8);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x608);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x630);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x688);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x698);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6b0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6c4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6f0);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x798);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7a0);
		break;
	}
	case WINDOWS_10_1703:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x624);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x628);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6b0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x610);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6a0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6b8);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6c8);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6cc);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x6f8);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7a0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7a8);
		break;
	}
	case WINDOWS_10_1709:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x624);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x628);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6b0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x610);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6d4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x700);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7a8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7b0);
		break;
	}
	case WINDOWS_10_1803:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x278);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x624);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x628);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6b0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x610);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6d4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x700);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7a8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7b0);
		break;
	}
	case WINDOWS_10_1809:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x23c);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x278);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2d8);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x368);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3d8);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x624);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x628);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6b0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x610);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x690);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6a8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6c0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6d4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x700);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7a0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7a8);
		break;
	}
	case WINDOWS_10_1903:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x248);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x280);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x370);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3e0);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x654);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x658);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6e0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x620);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x648);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x6a0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6b8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6e0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6e4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x710);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7b0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7b8);
		break;
	}
	case WINDOWS_10_1909:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x240);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x248);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x280);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x2e0);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x2e8);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x2f0);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x370);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x3e0);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x3f8);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x418);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x420);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x428);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x488);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x498);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x654);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x658);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x6e0);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x620);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x648);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x6a0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x6b8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x6d0);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x6e0);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x6e4);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x710);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x7b0);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x7b8);
		break;
	}
	case WINDOWS_10_20H1:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_10_20H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_10_21H1:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_10_21H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_10_22H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x450);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x478);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x4d0);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x4e8);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x500);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x510);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x514);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x548);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x5e8);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x5f0);
		break;
	}
	case WINDOWS_11_21H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x4a0);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x4c8);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x520);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x538);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x550);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x560);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x564);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x598);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x640);
		break;
	}
	case WINDOWS_11_22H2:
	{
		SET_GLOBAL_OFFSET(KPROCESS, DirectoryTableBase, 0x28);
		SET_GLOBAL_OFFSET(KPROCESS, ThreadListHead, 0x30);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessLock, 0x40);
		SET_GLOBAL_OFFSET(KPROCESS, StackCount, 0x348);
		SET_GLOBAL_OFFSET(KPROCESS, ProcessListEntry, 0x350);
		SET_GLOBAL_OFFSET(KPROCESS, UserDirectoryTableBase, 0x388);

		SET_GLOBAL_OFFSET(EPROCESS, ProcessLock, 0x438);
		SET_GLOBAL_OFFSET(EPROCESS, UniqueProcessId, 0x440);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveProcessLinks, 0x448);
		SET_GLOBAL_OFFSET(EPROCESS, AddressCreationLock, 0x4c8);
		SET_GLOBAL_OFFSET(EPROCESS, Win32WindowStation, 0x538);
		SET_GLOBAL_OFFSET(EPROCESS, Peb, 0x550);
		SET_GLOBAL_OFFSET(EPROCESS, ObjectTable, 0x570);
		SET_GLOBAL_OFFSET(EPROCESS, DebugPort, 0x578);
		SET_GLOBAL_OFFSET(EPROCESS, WoW64Process, 0x580);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListHead, 0x5e0);
		SET_GLOBAL_OFFSET(EPROCESS, ActiveThreads, 0x5f0);
		SET_GLOBAL_OFFSET(EPROCESS, ExitStatus, 0x7d4);
		SET_GLOBAL_OFFSET(EPROCESS, VadRoot, 0x7d8);
		SET_GLOBAL_OFFSET(EPROCESS, ThreadListLock, 0x860);

		SET_GLOBAL_OFFSET(KTHREAD, InitialStack, 0x28);
		SET_GLOBAL_OFFSET(KTHREAD, StackLimit, 0x30);
		SET_GLOBAL_OFFSET(KTHREAD, StackBase, 0x38);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadLock, 0x40);
		SET_GLOBAL_OFFSET(KTHREAD, KernelStack, 0x58);
		SET_GLOBAL_OFFSET(KTHREAD, ApcState, 0x98);
		SET_GLOBAL_OFFSET(KTHREAD, Teb, 0xf0);
		SET_GLOBAL_OFFSET(KTHREAD, State, 0x184);
		SET_GLOBAL_OFFSET(KTHREAD, Process, 0x220);
		SET_GLOBAL_OFFSET(KTHREAD, ThreadListEntry, 0x2f8);

		SET_GLOBAL_OFFSET(ETHREAD, StartAddress, 0x4a0);
		SET_GLOBAL_OFFSET(ETHREAD, Cid, 0x4c8);
		SET_GLOBAL_OFFSET(ETHREAD, Win32StartAddress, 0x520);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadListEntry, 0x538);
		SET_GLOBAL_OFFSET(ETHREAD, ThreadLock, 0x550);
		SET_GLOBAL_OFFSET(ETHREAD, CrossThreadFlags, 0x560);
		SET_GLOBAL_OFFSET(ETHREAD, SameThreadPassiveFlags, 0x564);
		SET_GLOBAL_OFFSET(ETHREAD, ExitStatus, 0x598);
		SET_GLOBAL_OFFSET(ETHREAD, UserFsBase, 0x638);
		SET_GLOBAL_OFFSET(ETHREAD, UserGsBase, 0x640);
		break;
	}
	default:
	{
		Status = STATUS_NOT_SUPPORTED;
		break;
	}
	}

	Status = STATUS_SUCCESS;

FINISH:
	PRINT_ELAPSED;
	return Status;
}

NTSTATUS DeviceInitialize(
	IN PDRIVER_OBJECT DriverObject)
{
#if TRACE_LOG_DEPTH & TRACE_ENTRY
#if _CLANG
	TraceLog(__PRETTY_FUNCTION__, __FUNCTION__);
#else
	TraceLog(__FUNCDNAME__, __FUNCTION__);
#endif
#endif

	SAVE_CURRENT_COUNTER;
	auto Status = STATUS_INVALID_PARAMETER;

FINISH:
	PRINT_ELAPSED;
	return Status;
}

VOID ShDrvExample::PeTest(
	IN HANDLE ProcessId, 
	IN HANDLE ProcessId32)
{
	PlainLog("======================== PE Sample =======================\n");
	//======================================================
	// Kernel Base
	//======================================================
	auto Pe = new(ShDrvPe);
	if (NT_SUCCESS(Pe->Initialize(g_Variables->SystemBaseAddress, PsInitialSystemProcess)))
	{
		Log("PE Test(Kernel Normal) %p", Pe->GetAddressByExport("ZwQuerySystemInformation"));
	}
	delete(Pe);

	//======================================================
	// Kernel Base(Session)
	//======================================================
	Pe = new(ShDrvPe);
	if (NT_SUCCESS(Pe->Initialize(g_Variables->Win32kBaseBaseAddress, PsInitialSystemProcess)))
	{
		Log("PE Test(Kernel Session) %p", Pe->GetAddressByExport("IsDwmApiPortRegistered"));
	}
	delete(Pe);

	//======================================================
	// Process Base(32)
	//======================================================
	Pe = new(ShDrvPe);
	auto Process = new(ShDrvProcess);
	LDR_DATA_TABLE_ENTRY32 LdrEntry32 = { 0, };
	if (NT_SUCCESS(Process->Initialize(ProcessId32)))
	{
		Process->GetProcessModuleInformation32("ntdll.dll", &LdrEntry32);
	}

	if (NT_SUCCESS(Pe->Initialize((PVOID)LdrEntry32.DllBase, Process->GetProcess(), true)))
	{
		Log("PE Test(Process 32) %p", Pe->GetAddressByExport("NtQuerySystemInformation"));
	}
	delete(Process);
	delete(Pe);

	//======================================================
	// Process Base(64)
	//======================================================
	Pe = new(ShDrvPe);
	Process = new(ShDrvProcess);
	LDR_DATA_TABLE_ENTRY LdrEntry = { 0, };
	if (NT_SUCCESS(Process->Initialize(ProcessId)))
	{
		Process->GetProcessModuleInformation("ntdll.dll", &LdrEntry);
	}

	if (NT_SUCCESS(Pe->Initialize(LdrEntry.DllBase, Process->GetProcess())))
	{
		Log("PE Test(Process 64) %p", Pe->GetAddressByExport("NtQuerySystemInformation"));
	}
	delete(Process);
	delete(Pe);
}

VOID ShDrvExample::ProcessTest(
	IN HANDLE ProcessId)
{
	PlainLog("======================== Process Sample(x64) =======================\n");

	auto Process = new(ShDrvProcess);
	PVOID* Result = nullptr;
	if (NT_SUCCESS(Process->Initialize(ProcessId)))
	{

		//======================================================
		// Process module 64
		//======================================================
		LDR_DATA_TABLE_ENTRY LdrEntry = { 0, };
		Process->GetProcessModuleInformation("ntdll.dll", &LdrEntry);

		//======================================================
		// Process read & write(physical) 64
		//======================================================
		USHORT ReadMagic = 0;
		USHORT AfterMagic = 0;
		USHORT WriteMagic = 0xffff;
		Process->ReadProcessMemory(LdrEntry.DllBase, 2, &ReadMagic);
		Process->WriteProcessMemory(LdrEntry.DllBase, 2, &WriteMagic, RW_Physical);
		Process->ReadProcessMemory(LdrEntry.DllBase, 2, &AfterMagic);
		Log("Original : %X, After : %X", ReadMagic, AfterMagic);
		Process->WriteProcessMemory(LdrEntry.DllBase, 2, &ReadMagic, RW_Physical);
		Log("%p %X", LdrEntry.DllBase, LdrEntry.SizeOfImage);

		//======================================================
		// Process memory scan 64
		//======================================================
		Result = reinterpret_cast<PVOID*>(ALLOC_POOL(NONE_SPECIAL));
		ULONG ResultCount = 0;

		ResultCount = Process->MemoryScan(
			LdrEntry.DllBase,
			LdrEntry.SizeOfImage,
			"4C 8B D1 B8 ?? ?? ?? ?? F6 04 25 08 03 FE 7F 01 75 03 0F 05 C3",
			Result);

		/*ResultCount = Process->MemoryScan(
			LdrEntry.DllBase,
			".text",
			"4C 8B D1 B8 ?? ?? ?? ?? F6 04 25 08 03 FE 7F 01 75 03 0F 05 C3",
			Result,
			nullptr,
			true);

		ResultCount = Process->MemoryScan(
			LdrEntry.DllBase,
			".text",
			"\x4c\x8b\xd1\xb8\x00\x00\x00\x00\xf6\x04\x25\x08\x03\xfe\x7f\x01\x75\x03\x0F\x05\xC3",
			&Result,
			"xxxx????xxxxxxxxxxxxx",
			true);*/

		for (auto i = 0; i < ResultCount; i++)
		{
			Log("[%d] %p", i, Result[i]);
		}
	}
	delete(Process);
	FREE_POOL(Result);
}

VOID ShDrvExample::ProcessTest32(
	IN HANDLE ProcessId32)
{
	PlainLog("======================== Process Sample(x86) =======================\n");
	auto Process = new(ShDrvProcess);
	PVOID* Result = nullptr;

	if (NT_SUCCESS(Process->Initialize((HANDLE)ProcessId32)))
	{
		//======================================================
		// Process module 32
		//======================================================
		LDR_DATA_TABLE_ENTRY32 LdrEntry32 = { 0, };
		Process->GetProcessModuleInformation32("ntdll.dll", &LdrEntry32);

		//======================================================
		// Process read & write(physical) 32
		//======================================================
		USHORT ReadMagic = 0;
		USHORT AfterMagic = 0;
		USHORT WriteMagic = 0xffff;
		Process->ReadProcessMemory((PVOID)LdrEntry32.DllBase, 2, &ReadMagic);
		Process->WriteProcessMemory((PVOID)LdrEntry32.DllBase, 2, &WriteMagic, RW_Physical);
		Process->ReadProcessMemory((PVOID)LdrEntry32.DllBase, 2, &AfterMagic);
		Log("Original : %X, After : %X", ReadMagic, AfterMagic);
		Process->WriteProcessMemory((PVOID)LdrEntry32.DllBase, 2, &ReadMagic, RW_Physical);
		Log("%p %X", LdrEntry32.DllBase, LdrEntry32.SizeOfImage);

		//======================================================
		// Process memory scan 32
		//======================================================
		Result = reinterpret_cast<PVOID*>(ALLOC_POOL(NONE_SPECIAL));
		ULONG ResultCount = 0;

		ResultCount = Process->MemoryScan(
			(PVOID)LdrEntry32.DllBase,
			LdrEntry32.SizeOfImage,
			"B8 ?? 00 00 00 BA 20 8F BE 77 FF D2 C2 ?? 00",
			Result);

		for (auto i = 0; i < ResultCount; i++)
		{
			Log("[%d] %p", i, Result[i]);
		}
	}
	delete(Process);
	FREE_POOL(Result);
}

VOID ShDrvExample::MemoryScanTest()
{
	PlainLog("======================== Memory Scanner(Kernel) Sample =======================\n");

	//======================================================
	// System address
	//======================================================
	auto Scanner = new(MemoryScanner);
	PVOID* Result = nullptr;
	if (NT_SUCCESS(Scanner->Initialize(g_Variables->SystemBaseAddress, ".text")))
	{
		Scanner->MakePattern("48 8B 81 ?? ?? ?? ?? C3");
		Scanner->Scan();

		Result = Scanner->GetScanResult();
		Log("%p", *Result);
	}
	delete(Scanner);

	//======================================================
	// Session address
	//======================================================
	Scanner = new(MemoryScanner);

	if (NT_SUCCESS(Scanner->Initialize(g_Variables->Win32kBaseBaseAddress, ".text")))
	{
		Scanner->MakePattern("33 C0 48 39 05 ?? ?? ?? ?? 0F 95 C0 C3");
		Scanner->Scan();

		Result = Scanner->GetScanResult();
		Log("%p", *Result);
	}
	delete(Scanner);
}
